<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Register Page</title>
    <link rel="stylesheet" href="/static/css/styles.css" />
</head>

<body>
    <div class="container">
        <h2>Register</h2>
        <form id="registerForm" autocomplete="off">
            <div class="form-group">
                <label for="username">Username:</label>
                <input list="usernameSuggestions" type="text" id="username" name="username" required />
                <div id="usernameSuggestions" class="usernameSuggestions"></div>
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" name="password" required />
            </div>
            <button type="submit">Register</button>
        </form>

        <p>Already have an account? <a href="/">Login here</a></p>
        <p id="message" style="color: red;"></p>
    </div>

    <script>
        let currentAbortController = null;

        const usernameInput = document.getElementById("username");
        const passwordInput = document.getElementById("password");
        const suggestionsList = document.getElementById("usernameSuggestions");
        const msg = document.getElementById("message");

        function debounce(func, delay) {
            let timeoutId; // This variable will store the ID of the setTimeout

            return function (...args) { // Returns a new function that will be the debounced version
                const context = this; // Preserves the 'this' context of the original function

                clearTimeout(timeoutId); // Clear any existing timeout to reset the timer

                timeoutId = setTimeout(() => { // Set a new timeout
                    func.apply(context, args); // Execute the original function after the delay
                }, delay);
            };
        }

        // ✅ Suggest usernames while typing (Gemini API call)
        async function usernameSuggestions() {
            // Abort any existing request
            if (currentAbortController) {
                currentAbortController.abort();
            }

            // Create new AbortController
            currentAbortController = new AbortController();

            const value = usernameInput.value.trim();
            suggestionsList.innerHTML = "";
            msg.textContent = "";

            if (value.length < 3) return;

            try {
                const res = await fetch(`/suggest_usernames?name=${encodeURIComponent(value)}`, {
                    signal: currentAbortController.signal
                });
                if (!res.ok) throw new Error("Gemini API error");

                const suggestions = await res.json();

                if (Array.isArray(suggestions)) {
                    suggestions.forEach(name => {
                        const spanELM = document.createElement("span");
                        spanELM.className = "suggestion-item";
                        spanELM.innerText = name;
                        spanELM.style.cursor = "pointer";
                        spanELM.addEventListener("click", () => {
                            usernameInput.value = name;
                            suggestionsList.innerHTML = "";
                        });
                        suggestionsList.appendChild(spanELM);
                    });
                }
            } catch (err) {
                // Don't log aborted requests as errors
                if (err.name === 'AbortError') {
                    console.log('Fetch aborted');
                    return;
                }
                console.error("Username suggestion error:", err);
            }
        }
        // Create a debounced version of your handler function with a 500ms delay
        const debouncedHandleSearch = debounce(usernameSuggestions, 500);

        usernameInput.addEventListener("keydown", async () => {
            console.log("Input changed, fetching suggestions..." + event.target.value);
            // await usernameSuggestions();
            debouncedHandleSearch(); // Call the debounced function
        });

        // ✅ Submit registration form
        document.getElementById("registerForm").addEventListener("submit", async (e) => {
            e.preventDefault();
            const username = usernameInput.value.trim();
            const password = passwordInput.value;

            msg.textContent = "";
            suggestionsList.innerHTML = "";
            msg.style.color = "red";

            try {
                const res = await fetch("/register", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ username, password })
                });

                const data = await res.json();

                if (!res.ok) {
                    msg.textContent = data.detail?.message || "Registration failed.";

                    // ✅ Show suggestions on duplicate username
                    const suggestions = data.detail?.suggestions || [];
                    suggestions.forEach(name => {
                        const option = document.createElement("option");
                        option.value = name;
                        suggestionsList.appendChild(option);
                    });
                    return;
                }

                // ✅ Success
                msg.style.color = "green";
                msg.textContent = data.message || "Registered successfully!";
                setTimeout(() => {
                    window.location.href = "/";
                }, 1500);

            } catch (error) {
                console.error("Registration error:", error);
                msg.textContent = "Server error. Please try again later.";
            }
        });

    </script>
</body>

</html>